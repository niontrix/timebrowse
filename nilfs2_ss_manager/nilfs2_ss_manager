#!/usr/bin/env python
#
#  copyright(c) 2011 - Jiro SEKIBA <jir@unicus.jp>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

"""nilfs snapshot manager"""

__author__    = "Jiro SEKIBA"
__copyright__ = "Copyright (c) 2011 - Jiro SEKIBA <jir@unicus.jp>"
__license__   = "GPL2"
__version__   = "0.4.1"

import nilfs2
import yaml
import time
import os
import stat
import re
import sys
import argparse
import gobject
import daemon
import daemon.pidlockfile
import commands
import syslog
import signal

class Logger:
    "A simple logger class which can redirect the output"
    def __init__(self, indent=False):
        if indent:
            self.__indent__ = indent
            self.out = self.syslog_out
        else:
            self.out = self.stderr_out

    def syslog_out(self, prio, string):
        "Write a given string to syslog"
        syslog.openlog(self.__indent__)
        syslog.syslog(prio, string)
        syslog.closelog()

    def stderr_out(self, prio, string):
        "Print a given string to the standard error output"
        print >> sys.stderr, string

class NILFSConfigurationException(Exception):
    def __init__(self, errors):
        self.errors = errors

class VersionException(Exception):
    def __init__(self):
        self.version = ["NILFS snapshot manager v" + __version__,
                        __copyright__]

def match_fs(path, fsnames):
    """
    Get the name of filesystem used on @path and return True if the
    filesystem name matches one of names in @fsnames.
    """
    cmd = 'stat -fc %T ' + path
    result = commands.getstatusoutput(cmd)
    return result[0] == 0 and (result[1] in fsnames)

class NILFSSSManager:
    def __init__(self, nilfs, mp, logger, **options):
        self.ns = nilfs
        self.mp = os.path.realpath(mp)
        self.logger = logger
        self.mounts = []
        self.aborting = False
        self.passive = 'passive' in options and options['passive']

    def lscp(self, refresh=False):
        cps = self.ns.lscp(refresh)[:]
        cps.reverse()
        return cps

    def snapshot_mount_point(self, cp):
        return self.mp + '/' + time.strftime("%Y.%m.%d-%H.%M.%S", cp['date'])

    def snapshot_is_mounted(self, cp):
        "Return if the specified checkpoint is mounted or not"
        path = self.snapshot_mount_point(cp)
        return os.path.ismount(path)
                                       # TODO: should also test device

    def do_mount_ss(self, refresh):
        "Create mount points for existing snapshots and mount them."
        for cp in self.lscp(refresh):
            if self.aborting:
                break
            if cp['ss']:
                if refresh and self.snapshot_is_mounted(cp):
                    continue  # skip if the snapshot is mounted
                self.do_mount(cp)

    def mount_ss(self):
        """
        Create mount points for existing snapshots and mount them.  If
        the mount point is on a nilfs filesystem, this will create a
        tmpfs on it so that making mount point directories does not
        trigger further checkpoint creation.
        """
        if match_fs(self.mp, ['nilfs', 'nilfs2']):
            self.mount_tmpfs()
        self.do_mount_ss(False)

    def create_dir(self, path):
        "Check if @path is present, and make the directory if not."
        if os.path.exists(path):
            if not os.path.isdir(path):
                 info = "path is not directory: %s" % path
                 self.logger.out(syslog.LOG_CRIT, info)
                 raise Exception(info)
        else:
            os.mkdir(path)

    def do_unmount_all(self, busy=[], failed=[]):
        "Unmount all snapshots and remove their mount point directories"
        for mp in self.mounts:
            cmd = 'umount -n %s' % mp
            result = commands.getstatusoutput(cmd)
            if result[0] == 0:
                cmd = 'rmdir %s' % mp
                commands.getstatusoutput(cmd)
                self.logger.out(syslog.LOG_INFO, "unmounted %s" % mp)
            elif result[0] == 256:
                self.logger.out(syslog.LOG_INFO,
                                "failed to unmount %s (busy)" % mp)
                busy.append(mp)
            else:
                self.logger.out(syslog.LOG_WARNING,
                                "failed to unmount %s (status=%d)" %
                                (mp, result[0]))
                failed.append(mp)
        self.mounts = busy

    def unmount_all(self):
        "Unmount all snapshots and retry it a few times for busy snapshots."
        busy = []
        failed = []
        self.do_unmount_all(busy, failed)

        retrycount = 2
        interval = 1
        while busy and retrycount > 0:
            self.logger.out(syslog.LOG_INFO,
                            "Retrying unmount (wait=%ds)" % interval)
            time.sleep(interval)
            busy = []
            self.do_unmount_all(busy, failed)
            interval <<= 1
            retrycount -= 1

        if match_fs(self.mp, ['tmpfs']):
            self.unmount_tmpfs()

    def do_mount(self, cp):
        """
        Create a sub-directory with a name based on timestamp @t and
        mount a snapshot given by the checkpoint information @cp on
        the directory.  On success, the sub-directory name will be
        appended to @self.mounts list.
        """
        target = self.snapshot_mount_point(cp)
        cmd = "mount -t nilfs2 -n -o ro,cp=%d" % cp['cno']
        cmd += " " + self.ns.device + " " + target
        self.create_dir(target)
        result = commands.getstatusoutput(cmd)
        if result[0] != 0:
            self.logger.out(syslog.LOG_CRIT, result[1])
            raise Exception(result[1])
        self.mounts.append(target)
        self.logger.out(syslog.LOG_INFO,
                        "mount ss = %d on %s" % (cp['cno'],target))

    def create_ss(self):
        """
        Get a list of recently created checkpoints, change them into
        snapshots, and mount them.
        """
        if self.aborting or self.passive: return
        for cp in self.lscp():
            if self.aborting:
                break
            if cp['ss']:
                break
            self.logger.out(syslog.LOG_INFO,
                            "create snapshot: ss = %d" % cp['cno'])
            self.ns.chcp(cp['cno'], True)
            self.do_mount(cp)

    def mount_tmpfs(self):
        "Create a tmpfs mount on @self.mp"
        cmd = 'mount -t tmpfs none ' + self.mp
        commands.getstatusoutput(cmd)

    def unmount_tmpfs(self):
        "Unmount the tmpfs mount on @self.mp"
        cmd = 'umount -t tmpfs ' + self.mp
        commands.getstatusoutput(cmd)

    def scan_mounts(self):
        "Restore mountpoints (self.mounts) from /proc/mounts"
        regex = re.compile(
            '^ *([^ ]+) +(' + self.mp +
            '/[^ ]+) +nilfs2 +[^ ]*cp=[\d]+[^ ]* +[^ ]+ +[^ ]+ *$', re.M)
        with open("/proc/mounts") as f:
            self.mounts = [m[1] for m in regex.findall(f.read())]

    def shutdown(self):
        """
        Set @self.aborting which shows if the daemon is an aborting phase,
        and unmount all snapshots.
        """
        self.aborting = True
        self.unmount_all()

    def update(self):
        "Check the new snapshots and mount them if exists"
        if self.passive:
            self.do_mount_ss(True)
        else:
            self.create_ss()

    def clean(self):
        """
        Retrieve a list of snapshot mounts from /proc/mounts and
        unmount them all.
        """
        self.scan_mounts()
        self.unmount_all()

def do_loop(interval, ss_managers):
    """
    Callback function to trigger snapshot managers.  This function is called
    periodically at intervals of the given @interval.
    """
    for manager in ss_managers:
        manager.update()
    gobject.timeout_add(interval, do_loop, interval, ss_managers)

class NODaemonContext:
    "Dummy daemon context class"
    def __init__(self):
        pass

    def __enter__(self):
        pass

    def __exit__(self, *excinfo):
        pass

def register_sighandlers(managers, mainloop):
    "Register signal handlers"
    def do_exit(a,b):
        for m in managers:
            m.shutdown()
        mainloop.quit()
    def do_update(a,b):
        for m in managers:
            m.update()
    signal.signal(signal.SIGINT, do_exit)
    signal.signal(signal.SIGTERM, do_exit)
    signal.signal(signal.SIGUSR1, do_update)

def check_configuration(conf):
    "Check if the configuration is valid"
    errors = []
    for key in ['devices', 'period', 'pidfile']:
        if not key in conf:
            errors.append("No '%s' key defined" % key)
        elif not conf[key]:
            errors.append("'%s' key has no value" % key)

    if len(errors) > 0:
        raise NILFSConfigurationException(errors)

try:
    logger = Logger()

    # Parse command line options
    parser = argparse.ArgumentParser(description="NILFS2 snapshot manager")
    parser.add_argument("-f", "--conf", dest='conffile',
                        default = '/etc/nilfs_ss.conf',
                        metavar = 'config',
                        help = 'config file')
    parser.add_argument("-C", "--clean", dest='clean', action='store_const',
                        default = False, const = True,
                        help = 'manually unmount all snapshots')
    parser.add_argument("-D", dest='daemonize', action='store_const',
                        default = True, const = False, 
                        help = 'do not daemonize')
    parser.add_argument("-P", "--passive", dest='passive',
                        action='store_const', default = False, const = True,
                        help = 'do not snapshot automatically (passive mode)')
    parser.add_argument("-V", "--version", dest='show_version',
                        action='store_const', default = False, const = True,
                        help = 'show version and exit')

    args = parser.parse_args()
    if args.show_version:
        raise VersionException()

    conffile = args.conffile
    daemonize = args.daemonize and not args.clean
    daemon_options = { 'passive': args.passive }

    # Read configuration file written in YAML format.
    conf = yaml.safe_load(open(conffile))
    check_configuration(conf)

    devices = conf['devices']
    period = conf['period']

    # Set up a daemon context. If no daemonize option is specfied, a
    # dummy context (NODaemonContext) will be used.
    dc = NODaemonContext()
    if daemonize:
        pidfile = conf['pidfile']
        dc = daemon.DaemonContext(
                    pidfile=daemon.pidlockfile.PIDLockFile(pidfile))
        logger = Logger(sys.argv[0])

    # Create snapshot managers for every device and mountpoint written
    # in conffile.
    managers = [NILFSSSManager(nilfs2.NILFS2(device), devices[device], logger,
                               **daemon_options)
                for device in devices]
 
    if args.clean:
        # Do cleanup job for every nilfs device if "clean" option is
        # specified.
        for manager in managers:
            manager.clean()
    else:
        # Initialize signal handlers and the timer to call back the
        # do_loop function periodically, and then kick every snapshot
        # manager.
        with dc:
            interval = period * 1000
            gobject.timeout_add(interval, do_loop, interval, managers)
            mainloop = gobject.MainLoop()
            register_sighandlers(managers, mainloop)
            for manager in managers:
                manager.mount_ss()
            mainloop.run()

except VersionException, e:
    for version in e.version:
        logger.out(syslog.LOG_INFO, version)

except NILFSConfigurationException, e:
    # Handle conffile errors
    logger.out(syslog.LOG_ERR, "Configuration error in %s" % conffile)
    for error in e.errors:
        logger.out(syslog.LOG_ERR, "  " + error),

except yaml.YAMLError, e:
    # Handle YAML errors
    pos = None
    if (hasattr(e, 'problem') and hasattr(e, 'context_mark') and
        hasattr(e, 'problem_mark')):
        if e.problem_mark is not None:
            pos = (e.problem_mark.line + 1, e.problem_mark.column + 1)
        elif e.context_mark is not None:
            pos = (e.context_mark.line + 1, e.context_mark.column + 1)

    logger.out(syslog.LOG_ERR, "Error" +
               (" near line %s, column %s" % pos if pos else "") +
               " while loading " + conffile)
    if hasattr(e, 'problem') and (e.problem is not None):
        logger.out(syslog.LOG_ERR, "  Reason: %s" % e.problem)
